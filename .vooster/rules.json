{
  "rules": [
    {
      "type": "prd",
      "content": "# AI 기반 동행 기도 PWA – PRD\n\n## 1. 제품 개요\n기독교 신앙인(20~50대)이 느끼는 기도 고립감을 해소하기 위해, AI가 맞춤형 기도문을 생성·낭독하고 ‘함께 기도 중인 인원’ 정보를 제공해 공동체적 동행감을 부여하는 웹 PWA.\n\n## 2. 문제 정의\n- 혼자 기도할 때 외로움과 동기 부족으로 꾸준한 기도 생활을 유지하지 못함.\n- 어떻게 기도해야 할지 막막하여 표현이 빈약해지고 집중력이 떨어짐.\n\n## 3. 사용자 목표\n- 꾸준하고 의미 있는 기도 생활을 유지하며 영적 자신감을 얻고 싶다.\n\n## 4. 주요 사용자\n- 20~50대 한국 개신교 신앙인, 모바일·웹 사용에 익숙하며 개인 기도 루틴을 강화하고 싶은 사람.\n\n## 5. 핵심 가치 제안\n- ‘누군가 나와 함께 기도한다’는 동행감을 주어 고립감을 해소.\n- AI가 나를 위한 맞춤 기도문을 작성·낭독해 집중력을 높임.\n\n## 6. 주요 기능 (MVP)\n| 분류 | 기능 | 설명 |\n|---|---|---|\n|1|맞춤형 AI 기도문 생성|사용자 입력(기도 제목/상황)에 기반해 4~5문장 기도문 생성|\n|2|TTS 기도문 낭독|따뜻한 음성, 일시정지·속도 조절 지원|\n|3|실시간 동행자 수 표시|Supabase Realtime으로 현재 기도 중인 인원 수 노출|\n|4|기도문 이미지 카드 공유|SNS 업로드용 카드 생성(다운로드/공유)|\n|5|구독자 전용 광고 제거 & 무제한 이용|월 구독 시 광고 숨김, 생성 횟수 무제한|\n\n## 7. 향후(Backlog) 기능\n- 기도 저널(묵상 및 응답 기록)\n- 소그룹 중보기도방\n- 단계별 기도 가이드\n\n## 8. 사용자 여정 핵심 시나리오\n1. 알림 또는 자발적 접속 ➜ 2. 기도 제목 입력 ➜ 3. AI 기도문 생성 확인 ➜ 4. ‘기도 시작’ 클릭 ➜ 5. TTS 낭독 + 동행자 수 표시 ➜ 6. 기도 완료/저장 ➜ 7. 이미지 카드 공유 또는 종료\n\n## 9. 성공 지표 (MVP)\n- D1 리텐션 ≥ 35%\n- 일 평균 기도 세션 시간 ≥ 3분\n- 구독 전환율 ≥ 5%\n\n## 10. 개발 전략\n- MVP 우선 출시(4~6주) → 사용자 피드백 수집 → 2주 단위 기능 개선.\n\n## 11. 기술 스택 (V1)\n- FE: Next.js + TypeScript + Tailwind CSS\n- BaaS: Supabase (PostgreSQL, Auth, Realtime, Edge Functions)\n- AI: OpenAI GPT-3.5, Naver Clova Speech TTS\n- 배포: Vercel\n\n## 12. 주요 리스크 & 대응\n| 리스크 | 대응 |\n|---|---|\n|AI 기도문의 신학적 정확성|검수 프롬프트 강화, 신고 기능|\n|TTS 비용 증가|캐싱·구독 플랜 분리|\n|실시간 사용자 수 정확도|세션 만료/타임아웃 로직 검증|\n",
      "writedAt": "2025-08-10T14:42:28.696Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n\n### 프로젝트 개요\n- AI 기반 동행 기도 PWA로, 사용자가 입력한 기도 제목·상황에 맞춰 AI가 맞춤형 기도문을 생성·낭독하며  \n  실시간 동행자 수를 제공하여 고립감을 해소하고 꾸준한 기도 생활을 유도  \n- Next.js 기반 PWA, Supabase BaaS, OpenAI GPT-3.5 및 Naver Clova TTS 연동, Vercel 배포  \n\n### 핵심 기술 스택\n- Frontend: Next.js + TypeScript + Tailwind CSS  \n- Backend/BaaS: Supabase (PostgreSQL, Auth, Realtime, Edge Functions)  \n- AI: OpenAI GPT-3.5  \n- TTS: Naver Clova Speech  \n- 배포·호스팅: Vercel  \n\n### 주요 기술 목표\n- 성능: 초기 로드 타임 1초 이내, AI 응답 2초 이내  \n- 확장성: 동시 사용자 1,000명 이상 수용 가능하도록 설계  \n- 안정성: 99.9% 가용성, 실시간 동행자 수 정확도 95% 이상  \n\n### 주요 가정\n- Supabase Realtime이 소규모 동시 사용자(수백 명) 수준에서 안정적 동기화 제공  \n- OpenAI·Clova TTS API 호출 비용 및 응답 속도가 대체로 일정  \n- 초기 사용자 규모는 1천 명 내외이며, 이후 단계별 확장 계획 수립  \n\n---\n\n## 2. Tech Stack\n\n| Category                   | Technology / Library         | Reasoning (Why it's chosen for this project)             |\n| -------------------------- | ---------------------------- | -------------------------------------------------------- |\n| Frontend Framework         | Next.js                      | PWA 기능(SSR/SSG, Service Worker), Vercel 연동 용이       |\n| Language                   | TypeScript                   | 정적 타입 검증, 코드 안정성 향상                          |\n| Styling                    | Tailwind CSS                 | 유틸리티 클래스 기반 빠른 UI 개발                         |\n| BaaS                       | Supabase                     | Auth, Realtime, PostgreSQL 통합 제공, 개발 속도 향상       |\n| AI Service                 | OpenAI GPT-3.5               | 높은 품질의 자연어 생성, 쉬운 API 연동                   |\n| TTS Service                | Naver Clova Speech           | 한국어 음성 품질 우수, API 호출 간편                      |\n| Hosting / CDN / CI·CD      | Vercel                       | Next.js와 최적화된 배포, 프리뷰 환경 지원, 자동 스케일링  |\n| Social Login & Auth        | Supabase Auth                | 구글·카카오·네이버 등 소셜 로그인 간편 통합               |\n| Payment Gateway            | Stripe (or Toss)             | 글로벌 및 국내 간편 결제, 구독 결제 기능 안정적 지원      |\n\n---\n\n## 3. System Architecture Design\n\n### Top-Level Building Blocks\n- Frontend (Next.js PWA)  \n  - Service Worker, 캐싱, PWA 설치  \n- BaaS Layer (Supabase)  \n  - 인증(Auth), Realtime, PostgreSQL, Edge Functions  \n- AI Integration  \n  - OpenAI GPT-3.5 호출 및 프롬프트 관리  \n- TTS Integration  \n  - Naver Clova Speech API 호출 및 오디오 캐싱  \n- CDN & Hosting  \n  - Vercel 배포, 자동 스케일링, HTTPS  \n\n### Top-Level Component Interaction Diagram\n```mermaid\ngraph TD\n    F[Frontend(PWA)] --> E[Edge Functions]\n    E --> A[OpenAI GPT-3.5]\n    E --> T[Naver Clova Speech]\n    F --> S[Supabase Realtime]\n    F --> D[Supabase PostgreSQL]\n    F --> P[Stripe/Toss]\n```\n- 사용자가 PWA(UI)에서 기도 제목 입력 후 요청  \n- Edge Functions가 OpenAI GPT-3.5 및 Clova TTS 호출  \n- Supabase Realtime을 통해 실시간 동행자 수 구독/갱신  \n- Supabase PostgreSQL에 세션·구독·사용자 정보 저장  \n- Stripe/Toss로 결제 처리 및 구독 상태 관리  \n\n### Code Organization & Convention\n\n**Domain-Driven Organization Strategy**\n- Domain Separation: `prayer`, `user`, `subscription`, `share`  \n- Layer-Based Architecture: Presentation(pages/components), Business Logic(services), Data Access(lib/db), Infrastructure(integrations)  \n- Feature-Based Modules: 각 도메인별 폴더에 UI·로직 밀집  \n- Shared Components: 공통 UI, 유틸리티, 타입 정의\n\n**Universal File & Folder Structure**\n```\n/\n├── public\n│   └── assets\n├── src\n│   ├── domains\n│   │   ├── prayer\n│   │   │   ├── components\n│   │   │   ├── services\n│   │   │   └── types\n│   │   ├── user\n│   │   ├── subscription\n│   │   └── share\n│   ├── pages\n│   │   ├── _app.tsx\n│   │   ├── index.tsx\n│   │   └── api\n│   ├── components\n│   ├── services\n│   ├── lib\n│   │   ├── db.ts\n│   │   ├── supabaseClient.ts\n│   │   └── apiClient.ts\n│   ├── styles\n│   └── utils\n├── supabase\n│   ├── migrations\n│   └── functions\n├── next.config.js\n├── tailwind.config.js\n└── package.json\n```\n\n### Data Flow & Communication Patterns\n- Client-Server 통신: Next.js API Routes 및 Supabase 클라이언트 사용  \n- Database Interaction: Supabase JS SDK + PostgREST, ORM 불필요  \n- External Service Integration: Edge Functions에서 OpenAI·Clova 호출, 응답 캐싱  \n- Real-time Communication: Supabase Realtime 구독(Presence)  \n- Data Synchronization: 사용자 세션 만료 처리, 캐시 무효화 로직  \n\n---\n\n## 4. Performance & Optimization Strategy\n- SSR/SSG 및 Incremental Static Regeneration 활용으로 초기 로드 최적화  \n- AI·TTS 응답 결과 오디오·텍스트 캐싱하여 재호출 비용 절감  \n- 이미지 카드 생성·공유 시 클라이언트 사이드 처리 및 Web Workers 활용  \n- Tailwind JIT 모드, 코드 분할(Code Splitting)으로 번들 크기 최소화  \n\n---\n\n## 5. Implementation Roadmap & Milestones\n\n### Phase 1: Foundation (MVP Implementation)\n- Core Infrastructure: Next.js 프로젝트 초기화, Supabase 세팅  \n- Essential Features: AI 기도문 생성, TTS 낭독, 실시간 동행자 수, 기본 UI  \n- Basic Security: Supabase Auth, HTTPS, CORS 설정  \n- Development Setup: GitHub Actions CI, Vercel Preview 배포  \n- Timeline: 4~6주\n\n### Phase 2: Feature Enhancement\n- Advanced Features: 공유 카드 생성/다운로드, 구독 결제 로직  \n- Performance Optimization: 캐싱 전략 강화, 로딩 스켈레톤  \n- Enhanced Security: 결제 정보 암호화, Rate Limiting  \n- Monitoring Implementation: Sentry 오류 모니터링, Vercel Analytics  \n- Timeline: 2~4주\n\n### Phase 3: Scaling & Optimization\n- Scalability Implementation: Supabase Horizontal Scaling, DB 인덱스 최적화  \n- Advanced Integrations: 소그룹 중보기도, 기도 저널 모듈  \n- Enterprise Features: 관리자 대시보드, A/B 테스트  \n- Compliance & Auditing: 개인정보보호법, PCI DSS 준수  \n- Timeline: 4~6주\n\n---\n\n## 6. Risk Assessment & Mitigation Strategies\n\n### Technical Risk Analysis\n- Technology Risks: AI 응답 품질 저하 → 프롬프트 튜닝, 신고 기능  \n- Performance Risks: Realtime 부하 증가 → 세션 타임아웃, Connection Pool 관리  \n- Security Risks: 인증·결제 취약점 → Supabase 보안 규칙, HTTPS·CSP 적용  \n- Integration Risks: 외부 API 장애 → 타임아웃·재시도 로직, 장애 대체 메시지 제공  \n- Mitigation Strategies: 단계별 부하 테스트, 비용 모니터링, 롤백 전략 수립  \n\n### Project Delivery Risks\n- Timeline Risks: 요구사항 변경 → 스코프 우선순위 조정, 스프린트 리뷰  \n- Resource Risks: AI·인프라 전문성 부족 → 외부 컨설팅, 문서화 강화  \n- Quality Risks: 테스트 부족 → 유닛·통합 테스트, 코드 리뷰 강화  \n- Deployment Risks: CI/CD 오류 → 프리뷰 환경 검증, 롤링 배포 전략  \n- Contingency Plans: 기능 축소 출시, 백업 환경 구성, 인력·일정 버퍼 확보",
      "writedAt": "2025-08-10T14:42:28.696Z"
    },
    {
      "type": "guideline",
      "content": "# AI 기반 동행 기도 PWA - Code Guidelines\n\n## 1. Project Overview\n\nThis project is a PWA designed to provide AI-generated personalized prayers, TTS functionality, and a real-time concurrent user count to foster a sense of community among Christian users. The core technology stack includes Next.js, TypeScript, Tailwind CSS, Supabase, OpenAI GPT-3.5, and Naver Clova Speech TTS. The architecture follows a domain-driven approach with separation of concerns into distinct layers.\n\n## 2. Core Principles\n\n-   **Maintainability:** Code should be easy to understand, modify, and extend.\n-   **Readability:** Code should be clear, concise, and well-documented.\n-   **Testability:** Code should be designed to facilitate unit and integration testing.\n-   **Performance:** Code should be optimized for speed and efficiency.\n-   **Security:** Code should be written to prevent common security vulnerabilities.\n\n## 3. Language-Specific Guidelines\n\n### TypeScript\n\n*   **File Organization and Directory Structure:** Adhere to the Domain-Driven Organization Strategy defined in the TRD.\n    *   Group files by feature or domain.\n    *   Use a consistent naming convention (e.g., `prayerService.ts`, `PrayerCard.tsx`).\n*   **Import/Dependency Management:**\n    *   Use absolute imports for internal modules (e.g., `import PrayerCard from 'components/PrayerCard';`).\n    *   Install dependencies using `npm` or `yarn` and manage them in `package.json`.\n    *   Avoid circular dependencies.\n*   **Error Handling Patterns:**\n    *   Use `try...catch` blocks for handling potential exceptions.\n    *   Implement centralized error logging and reporting.\n    *   Create custom error classes for specific domain errors.\n\n### Next.js\n\n*   **File Organization:** Follow the standard Next.js directory structure (e.g., `pages`, `components`, `public`, `styles`).\n*   **API Routes:** Place API route handlers in the `pages/api` directory.\n*   **Data Fetching:** Use `getServerSideProps` for server-side rendering and `getStaticProps` for static site generation.\n*   **Linking:** Use the `<Link>` component for internal navigation.\n\n### Tailwind CSS\n\n*   **Class Naming:** Use descriptive and consistent class names.\n*   **Customization:** Customize Tailwind CSS using `tailwind.config.js`.\n*   **Responsive Design:** Utilize Tailwind's responsive modifiers (e.g., `md:`, `lg:`) for different screen sizes.\n*   **Component Extraction:** Extract common styling patterns into reusable components.\n\n### Supabase\n\n*   **Client Initialization:** Initialize the Supabase client in a dedicated module (e.g., `supabaseClient.ts`).\n*   **Data Fetching:** Use the Supabase client to perform CRUD operations on the PostgreSQL database.\n*   **Realtime Updates:** Use Supabase Realtime for broadcasting real-time data.\n*   **Edge Functions:** Use Supabase Edge Functions for custom backend logic.\n\n### OpenAI GPT-3.5 & Naver Clova Speech TTS\n\n*   **API Integration:** Create dedicated services for interacting with the OpenAI and Naver Clova APIs (e.g., `prayerService.ts`, `ttsService.ts`).\n*   **Error Handling:** Implement robust error handling for API calls.\n*   **Caching:** Implement caching strategies to reduce API calls and improve response times.\n*   **Rate Limiting:** Implement rate limiting to prevent abuse of the APIs.\n\n## 4. Code Style Rules\n\n#### MUST Follow:\n\n*   **Use TypeScript:** All code MUST be written in TypeScript to ensure type safety and maintainability.\n    *   Rationale: TypeScript provides static typing, which helps catch errors early in the development process and improves code readability.\n    *   Implementation: Enforce TypeScript usage through project configuration and code review.\n*   **Follow a Consistent Code Style:** Code MUST adhere to a consistent code style, enforced by ESLint and Prettier.\n    *   Rationale: Consistent code style improves readability and maintainability.\n    *   Implementation: Configure ESLint and Prettier with appropriate rules and integrate them into the development workflow.\n*   **Write Unit Tests:** Unit tests MUST be written for all core logic and components.\n    *   Rationale: Unit tests ensure that code functions as expected and prevent regressions.\n    *   Implementation: Use Jest or a similar testing framework and aim for high test coverage.\n*   **Use Meaningful Names:** Variables, functions, and classes MUST have meaningful names that clearly indicate their purpose.\n    *   Rationale: Meaningful names improve code readability and understanding.\n    *   Implementation: Follow a consistent naming convention and avoid abbreviations or acronyms.\n*   **Document Code:** Code MUST be documented using JSDoc-style comments.\n    *   Rationale: Documentation helps explain the purpose and usage of code.\n    *   Implementation: Document all functions, classes, and interfaces with clear and concise comments.\n*   **Handle Errors Properly:** All potential errors MUST be handled gracefully using `try...catch` blocks or similar mechanisms.\n    *   Rationale: Proper error handling prevents unexpected crashes and provides a better user experience.\n    *   Implementation: Log errors and display informative messages to the user.\n*   **Use Environment Variables:** Sensitive information such as API keys and database credentials MUST be stored in environment variables.\n    *   Rationale: Environment variables prevent sensitive information from being exposed in the codebase.\n    *   Implementation: Use a library such as `dotenv` to load environment variables from a `.env` file.\n*   **Keep Components Small and Focused:** React components MUST have a single responsibility and be as small as possible.\n    *   Rationale: Small, focused components are easier to understand, test, and reuse.\n    *   Implementation: Break down large components into smaller, more manageable pieces.\n*   **Use Functional Components with Hooks:**  Favor functional components with hooks over class components.\n    *   Rationale: Functional components with hooks are more concise and easier to test.\n    *   Implementation: Use `useState`, `useEffect`, and other hooks to manage state and side effects.\n*   **Optimize Performance:** Code MUST be optimized for performance to ensure a smooth user experience.\n    *   Rationale: Performance optimization reduces load times and improves responsiveness.\n    *   Implementation: Use techniques such as code splitting, caching, and image optimization.\n\n#### MUST NOT Do:\n\n*   **Commit Sensitive Information:** API keys, database passwords, and other sensitive information MUST NOT be committed to the repository.\n    *   Rationale: Committing sensitive information can lead to security breaches.\n    *   Implementation: Use environment variables and `.gitignore` to prevent sensitive information from being committed.\n*   **Ignore Errors:** Errors MUST NOT be ignored or suppressed without proper handling.\n    *   Rationale: Ignoring errors can lead to unexpected behavior and make it difficult to debug issues.\n    *   Implementation: Log errors and display informative messages to the user.\n*   **Write Complex Components:** AVOID writing complex, multi-responsibility module in single file.\n    *   Rationale: Complex modules are hard to test and maintain.\n    *   Implementation: Break down complex modules into smaller, more manageable modules.\n*   **Implement Complex State Management:** AVOID defining complex state management pattern unless absolutely necessary. Favor simpler solutions like `useState` or `useReducer` where appropriate.\n    *   Rationale: Overly complex state management can increase the complexity of the codebase.\n    *   Implementation: Evaluate state management needs carefully before choosing a solution.\n*   **Use `any` Type:** AVOID using `any` type in Typescript, except when absolutely necessary and with a clear justification.\n    *   Rationale: Using `any` defeats the purpose of Typescript's type system.\n    *   Implementation: Strive to provide specific types for all variables and function parameters.\n*   **Mutate State Directly:**  MUST NOT mutate state directly in React components.\n    *   Rationale: Direct state mutation can lead to unexpected behavior and performance issues.\n    *   Implementation: Use the `setState` method or the `useState` hook to update state.\n*   **Use Inline Styles:** AVOID using inline styles in React components.\n    *   Rationale: Inline styles are difficult to maintain and can lead to code duplication.\n    *   Implementation: Use CSS classes or a styling library such as Tailwind CSS.\n*   **Introduce Technical Debt Unnecessarily:** Technical debt MUST NOT be introduced without a clear plan for addressing it.\n    *   Rationale: Technical debt can lead to increased development costs and reduced code quality.\n    *   Implementation: Prioritize code quality and refactor code regularly.\n\n## 5. Architecture Patterns\n\n*   **Component/module structure guidelines:**\n    *   Follow the Domain-Driven Organization Strategy.\n    *   Separate components into presentational and container components.\n    *   Use a consistent naming convention for components and modules.\n*   **Data flow patterns:**\n    *   Use unidirectional data flow.\n    *   Pass data down from parent components to child components.\n    *   Use callbacks to communicate events from child components to parent components.\n*   **State management conventions:**\n    *   Use React Context API for global state.\n    *   Use Redux or similar library for complex state management scenarios.\n    *   Favor simpler solutions like `useState` or `useReducer` where appropriate.\n*   **API design standards:**\n    *   Use RESTful API conventions.\n    *   Use JSON for data exchange.\n    *   Implement authentication and authorization.\n    *   Handle errors gracefully.\n\n## Example Code Snippets\n\n```typescript\n// MUST: Example of a well-documented function\n/**\n * Generates a personalized prayer using OpenAI GPT-3.5.\n * @param topic The topic of the prayer.\n * @returns A promise that resolves to the generated prayer text.\n */\nasync function generatePrayer(topic: string): Promise<string> {\n  // Implementation details\n  return \"Generated Prayer\";\n}\n// Explanation: This function is well-documented with JSDoc-style comments,\n// making it easy to understand its purpose and usage.\n```\n\n```typescript\n// MUST NOT: Example of using 'any' type\nfunction processData(data: any): void {\n  // Avoid using 'any' - specify the expected type instead\n  console.log(data.name); // Potential runtime error if 'data' doesn't have a 'name' property\n}\n// Explanation: Using 'any' defeats the purpose of TypeScript and can lead to runtime errors.\n// Fix: Define an interface or type for the expected data structure.\n```\n\n```typescript\n// MUST: Example of a functional component with hooks\nimport React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n// Explanation: This component uses the useState hook to manage state,\n// making it concise and easy to understand.\n```\n\n```typescript\n// MUST NOT: Example of direct state mutation\nfunction updateObject(obj: {name: string}) {\n  obj.name = \"New Name\"; // Direct state mutation is bad\n  // ...\n}\n\n// Correct way:\nfunction updateObjectCorrectly(obj: {name: string}) {\n  return {...obj, name: \"New Name\"}; // Create new object\n}\n// Explanation: Mutating state directly can cause unexpected behavior.\n// Always create new objects or arrays when updating state.\n```\n\n```typescript\n// MUST: Example of using environment variables\nconst apiKey = process.env.OPENAI_API_KEY;\n\nif (!apiKey) {\n  console.error('OPENAI_API_KEY is not set in environment variables.');\n}\n// Explanation: API keys and other sensitive information should be stored in environment variables\n// and accessed using process.env. This prevents them from being committed to the repository.\n```\n\n```typescript\n// MUST: Example of using try...catch for error handling\nasync function fetchData() {\n  try {\n    const response = await fetch('/api/data');\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('Error fetching data:', error);\n    // Handle the error appropriately, e.g., display an error message to the user\n    return null;\n  }\n}\n// Explanation: Wrapping asynchronous operations in try...catch blocks allows you to handle potential errors gracefully.\n```\n",
      "writedAt": "2025-08-10T14:42:28.696Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-08-10T14:42:28.696Z"
    },
    {
      "type": "isms-p",
      "content": "\n# ISMS-P Based Secure Development Rules (v1.0)\n# This document defines the mandatory security rules for developers during code implementation.\n# Reference: Based on the Information Security Management System - Personal Information (ISMS-P) standard.\n\n## 1. Authentication & Authorization\n- **(A-1) User Identification and Authentication**\n  - **MUST**: Every user must be individually identifiable. The use of shared accounts is prohibited.\n  - **MUST**: Passwords MUST satisfy one of the following policies:\n    - (a) 8+ characters with a mix of letters, numbers, and special characters.\n    - (b) 10+ characters with a mix of letters and numbers.\n  - **MUST**: An account lockout policy MUST be implemented for failed login attempts (e.g., lock the account for 5 minutes after 5 consecutive failures).\n\n- **(A-2) Management of Authentication Credentials**\n  - **MUST**: Authentication credentials such as passwords MUST be stored using an adaptive hash function like **bcrypt, scrypt, or Argon2**. (Using SHA-256 alone is prohibited).\n\n- **(A-3) Privilege Management**\n  - **MUST**: Grant only the minimum necessary privileges for a role, following the **Principle of Least Privilege**.\n  - **MUST**: All actions of granting, changing, and revoking privileges MUST be logged.\n\n- **(A-4) Privileged Access Management**\n  - **MUST**: Administrative privileges (e.g., root, admin) MUST be granted to a minimum number of users, and the reason for using such accounts MUST be clearly logged.\n  - **SHOULD**: Administrative accounts SHOULD be separate from regular user accounts.\n\n## 2. Access Control\n- **(AC-1) System Access**\n  - **MUST**: Access to information systems by unauthorized users MUST be blocked.\n  - **MUST**: Access logs for critical systems MUST be retained for **at least one year**.\n\n- **(AC-2) Network Access**\n  - **MUST**: Public-facing services MUST be located in a **DMZ**, separate from the internal network.\n  - **MUST**: Firewalls MUST allow only the minimum necessary ports required for the service. (Prohibit \"allow all\" rules).\n\n## 3. Cryptography\n- **(C-1) Encryption of Sensitive Information**\n  - **MUST**: Legally defined sensitive information (e.g., national ID numbers, passport numbers, bank account numbers, credit card numbers) and passwords MUST be encrypted during storage and transmission.\n  - **MUST**: Use secure and vetted cryptographic algorithms such as **AES-256**.\n  - **MUST NOT**: Do not use homegrown or custom-developed cryptographic algorithms.\n\n- **(C-2) Cryptographic Key Management**\n  - **MUST NOT**: Do not hardcode cryptographic keys in source code, configuration files, or comments.\n  - **MUST**: Cryptographic keys MUST be managed securely using **environment variables** or a dedicated **Key Management System (KMS, HSM)**.\n  - **MUST**: Minimize access to keys and log all lifecycle management procedures, including generation, use, and destruction.\n\n## 4. Secure Development\n- **(D-1) Secure Design**\n  - **MUST**: Defense mechanisms against major vulnerabilities like the **OWASP Top 10** (e.g., SQL Injection, XSS, CSRF) MUST be incorporated during the design phase.\n\n- **(D-2) Secure Coding**\n  - **MUST**: Treat all external input (e.g., request parameters, headers, cookies) as untrusted. **Validation and sanitization** logic MUST always be applied.\n  - **MUST**: All SQL queries MUST use **parameterized queries (prepared statements)**. (Dynamic query string concatenation is prohibited).\n  - **MUST**: When handling errors, ensure that internal system details (e.g., stack traces, database information) are not exposed to the user.\n\n- **(D-3) Security Testing**\n  - **SHOULD**: Periodically scan for security vulnerabilities using static/dynamic analysis tools (**SAST/DAST**).\n\n## 5. Personal Information Handling\n- **(P-1) Collection and Use**\n  - **MUST**: Collect only the minimum personal information necessary to provide the service. The purpose of collection MUST be clearly disclosed to users, and consent must be obtained.\n  - **MUST NOT**: Do not process sensitive information (e.g., beliefs, ideology) or unique identification information without a legal basis or separate user consent.\n\n- **(P-2) Storage and Display**\n  - **MUST**: Personal information MUST be **masked** when displayed on screen (e.g., John D**, +1-***-***-1234, test@****.com).\n  - **MUST NOT**: Do not use personal information or provide it to third parties beyond the scope of the consented purpose.\n\n- **(P-3) Destruction**\n  - **MUST**: When the retention period expires or the processing purpose is achieved, personal information MUST be completely destroyed using an irreversible method.\n  - **MUST**: Establish a personal information destruction procedure and maintain a log of all destructions.\n\n## 6. Logging & Management\n- **(L-1) Log Recording**\n  - **MUST**: Logs for critical activities (e.g., login, access to personal information, privilege changes) MUST be securely retained for **at least one year**.\n  - **MUST**: Logs MUST be standardized and include at least the following: [Timestamp, User ID, Source IP Address, Request/Action, Success/Failure Status].\n",
      "writedAt": "2025-08-10T14:42:28.696Z"
    }
  ]
}